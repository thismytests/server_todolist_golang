package postgressql

import (
	"context"
	"database/sql"
	"fmt"
	"main/appconfig"
	repo "main/db/repository"
	"time"
)

type repository struct {
	db *sql.DB
}

// todo ... Mykolai Lytvyn ... will be updated
func NewRepository() *sql.DB {
	const envFilePath = "../env/.env.dev"
	config := appconfig.ReadEnvFile(envFilePath)

	connStr := fmt.Sprintf("dbname=%s user=%s password=%s sslmode=disable",
		config.POSTGRES_DATABASE_NAME,
		config.POSTGRES_DATABASE_USERNAME,
		config.POSTGRES_DATABASE_PASSWORD,
	)

	db, err := sql.Open("postgres", connStr)

	if err != nil {
		panic(err)
	}

	return db
}

func CreateTodoListTable(db *sql.DB) {
	_, err := db.Exec("CREATE TABLE IF NOT EXISTS  todolist (id   integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, text  varchar(30) NOT NULL, isSelected varchar(30) NOT NULL)")

	if err != nil {
		panic(err)
	}
}

func (r *repository) Close() {
	r.db.Close()
}

func (r *repository) FindByID(id string) (*repo.TodoListModel, error) {
	todolist := new(repo.TodoListModel)

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	err := r.db.QueryRowContext(ctx, "SELECT id, text, isSelected FROM todolist WHERE id = ?", id).
		Scan(&todolist.Id, &todolist.Text, &todolist.IsSelected)

	if err != nil {
		return nil, err
	}

	return todolist, nil
}

func (r *repository) Find() ([]*repo.TodoListModel, error) {
	todolistItems := make([]*repo.TodoListModel, 0)

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	rows, err := r.db.QueryContext(ctx, "SELECT id, text, isSelected FROM todolist")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		todoListItem := new(repo.TodoListModel)
		err = rows.Scan(
			&todoListItem.Id,
			&todoListItem.Text,
			&todoListItem.IsSelected,
		)

		if err != nil {
			return nil, err
		}
		todolistItems = append(todolistItems, todoListItem)
	}

	return todolistItems, nil
}

func (r *repository) Create(todolistItem *repo.TodoListModel) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	query := "INSERT INTO todolist (text, isSelected) VALUES ($1, $2)"

	stmt, err := r.db.PrepareContext(ctx, query)

	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.ExecContext(ctx, todolistItem.Text, todolistItem.IsSelected)

	return err
}

func (r *repository) Update(todolistItem *repo.TodoListModel) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	query := "UPDATE todolist SET text = ?, isSelected = ?, WHERE id = ?"
	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.ExecContext(ctx, todolistItem.Text, todolistItem.IsSelected)
	return err
}

func (r *repository) Delete(id string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	query := "DELETE FROM todolist WHERE id = $1"
	stmt, err := r.db.PrepareContext(ctx, query)
	if err != nil {
		return err
	}
	defer stmt.Close()

	_, err = stmt.ExecContext(ctx, id)
	return err
}

func DBRepository() repo.Repository {
	return &repository{
		db: NewRepository(),
	}

}
